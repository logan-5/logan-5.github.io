<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.0 -->
<title>Stop Using Bare Strings | Your awesome title</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Stop Using Bare Strings" />
<meta name="author" content="logan" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." />
<meta property="og:description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." />
<link rel="canonical" href="http://localhost:4000/2019/01/19/stop-using-bare-strings.html" />
<meta property="og:url" content="http://localhost:4000/2019/01/19/stop-using-bare-strings.html" />
<meta property="og:site_name" content="Your awesome title" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-19T21:28:10-08:00" />
<script type="application/ld+json">
{"description":"Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.","author":{"@type":"Person","name":"logan"},"@type":"BlogPosting","url":"http://localhost:4000/2019/01/19/stop-using-bare-strings.html","headline":"Stop Using Bare Strings","dateModified":"2019-01-19T21:28:10-08:00","datePublished":"2019-01-19T21:28:10-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/01/19/stop-using-bare-strings.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Your awesome title" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Your awesome title</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">
				Stop Using Bare Strings		</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-01-19T21:28:10-08:00" itemprop="datePublished">Jan 19, 2019
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">logan</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>I was going to use the word “naked” in the title, but decided against it when I realized there’s enough nudity on the Internet already.</p>

<p><a href="https://www.youtube.com/watch?v=5tg1ONG18H8">This amazing-as-usual talk by Scott Meyers</a> has been haunting my brain recently, and it actually has nothing to do with his hair. He drives home important points that <em>should</em> haunt the brain of anyone who strives to leave a positive legacy with the work they’ve done. Anyone whose biggest fear is poor innocent souls using his or her code down the line, staring in uncomprehending horror or aching disgust, and when the <code class="highlighter-rouge">git blame</code> comes with its unwavering judgment, they sigh and mutter, “Yep, the usual suspect.” Anyone whose genuine desire is to write code that is, to harp on another Meyers-ism, “easy to use correctly, and hard to use incorrectly.”</p>

<p>Watch the talk.</p>

<p>Near the end of the talk, Scott Meyers brings down his flaming sword upon the habit of many programmers, myself often included, to over-rely on strings. It was an argument I hadn’t thoroughly considered before, and it left me feeling exposed, ashamed, and penitent, as divine judgment always does.</p>

<p>I want to contribute some thoughts on the matter, some shapes the problem takes, and some possible solutions.</p>

<h2 id="the-problem">The Problem</h2>

<p>Consider the following function:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::unique_ptr&lt;Texture&gt; load(const std::string&amp; path);
</code></pre></div></div>

<p>Without being able to see its definition, what do we know about it? What do we <em>not</em> know about it?</p>

<p>Well, clearly it’s going to do some interaction with the file system to load some type of file, and create some sort of in-memory representation of a <code class="highlighter-rouge">Texture</code>, whatever that is (maybe we’re in a graphics application?). A <code class="highlighter-rouge">Texture</code> is big enough that we want to put it on the heap (or perhaps it’s polymorphic), and we’re getting a <code class="highlighter-rouge">unique_ptr</code> to it, which is good–safety and efficiency by default, and we can always move it into a <code class="highlighter-rouge">shared_ptr</code> later if we need to.</p>

<p>What are we ignoring? If you’re anything like me (and it’s quite possible I’m alone here), there is an actual pang of anxiety when you see the <code class="highlighter-rouge">path</code> parameter, accompanied by a question: what kind of path? Absolute? Relative? If relative, relative to where? If I got the string I’m going to call this function with from somewhere else, how can I be sure it’s the right type of path? Is it my job to do that, or is the function going to somehow validate the path, or convert relative paths to absolute paths, or something?</p>

<p>What’s even more interesting than the pang of anxiety is that I, at least, have <em>learned to ignore</em> it, because having absolute certainty about how to call functions is not something I have come to expect from programming. I expect to probably get it wrong the first time… I’ll spend a couple minutes looking for the problem, and then I’ll figure it out, and it’ll be fine. Except when that couple minutes turns into a couple hours, or a couple days….</p>

<p>Alright, sorry. Less pontificating, more code. We get it, the string parameter is scary. I get rambly like this sometimes.</p>

<h2 id="some-solutions">Some Solutions</h2>

<p>Here’s one possible, tempting solution to this problem:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using AbsolutePath = std::string; 
// ... 
std::unique_ptr&lt;Texture&gt; load(const AbsolutePath&amp; path);
</code></pre></div></div>

<p>This is definitely a step in the right direction. The function definition is now <em>much</em> more readable–it clearly expects an absolute path, and to be honest, it goes a long, long way toward eliminating my anxiety about calling this function–I know exactly how to do it correctly now. In codebases I’ve worked on, I’ve stopped here, and felt relatively good about it.</p>

<p>But of course, this relies on users of the function to go to the declaration to read the signature, and isn’t resistant to incremental refactoring, nor does it have even a smidgen of type safety. Since <code class="highlighter-rouge">AbsolutePath</code> is just an alias for <code class="highlighter-rouge">std::string</code>, we have gained nothing at the call site:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const std::string relativePath = "my_stuff/texture.png";
auto texture = load(relativePath);
</code></pre></div></div>

<p>Even more blatantly/offensively:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const std::string relativePath = "my_stuff/texture.png";
const AbsolutePath absolutePath = relativePath;
</code></pre></div></div>

<p>In a perfect world, I would be warned, by the compiler or the linter or something, about making that mistake. No, scratch that–in a perfect world, it should be <em>impossible</em> to make that mistake.</p>

<p>In fact, this is something that type systems are great for, and C++ comes with a very sophisticated, robust, and expressive one.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct AbsolutePath {
     explicit AbsolutePath(std::string s) : path{std::move(s)} {}
     std::string path;
}; 
struct RelativePath {
     explicit RelativePath(std::string s) : path{std::move(s)} {}
     std::string path;
};
</code></pre></div></div>

<p>Now we get a compiler error:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const RelativePath relativePath = {"my_stuff/texture.png"};
const AbsolutePath = relativePath; // error: no viable conversion from 'RelativePath' to 'AbsolutePath'
</code></pre></div></div>

<p>This is good. We are prevented by the compiler from passing in the wrong type of path to <code class="highlighter-rouge">load</code>. Also, we can’t just pass in plain strings to <code class="highlighter-rouge">load</code> anymore either (note the <code class="highlighter-rouge">explicit</code> constructors), giving the programmer an error if they try, and more importantly an impetus to stop and think about what they are trying to pass in. The only cost of these benefits is changing usage of the <code class="highlighter-rouge">path</code> argument in the implementation of <code class="highlighter-rouge">load</code> to <code class="highlighter-rouge">path.path</code> instead, grabbing the inner string out of the wrapper.</p>

<p>This API is now “hard to use incorrectly,” to echo the Meyers mantra. But we still have (at least) one more step we can take toward making it “easy to use correctly.” A key observation is that we can (probably, depending on the exact situation) create AbsolutePaths from RelativePaths in a programmatic way–appending the <code class="highlighter-rouge">pwd</code> and doing tilde expansion and all that jazz. Let’s say we have correctly and neatly implemented that functionality in this function:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::string makeAbsolutePath(const std::string&amp; relativePath);
</code></pre></div></div>

<p><em>(I’m not too worried about the <code class="highlighter-rouge">std::string</code>s in this signature–this function’s job is to take the actual sequence of characters that make up a relative path, and transform them into the sequence of characters that comprise an absolute path. Hopefully it’s a static function tucked away in an implementation file somewhere, away from possible misuse.)</em></p>

<p>Look what happens now, if we juggle our implementations of our path structs around a bit:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct RelativePath {
    explicit RelativePath(std::string s) : path{std::move(s)} {}
    std::string path;
};
struct AbsolutePath {
    explicit AbsolutePath(std::string s) : path{std::move(s)} {}
    AbsolutePath(const RelativePath&amp; r) : path{makeAbsolutePath(r.path)} {}
    std::string path;
};
</code></pre></div></div>

<p>What happened here? We have a new constructor taking a <code class="highlighter-rouge">RelativePath</code> which calls the appropriate conversion on the internal <code class="highlighter-rouge">std::string</code>s. Notably, this new constructor is not <code class="highlighter-rouge">explicit</code>, leading to some cool conveniences:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>auto texture = load(RelativePath{"my_stuff/texture.png"});
</code></pre></div></div>

<p>Wait, we passed a <code class="highlighter-rouge">RelativePath</code> to <code class="highlighter-rouge">load</code>? That’s right! Because the <code class="highlighter-rouge">AbsolutePath</code> constructor in question was not made <code class="highlighter-rouge">explicit</code>, you can <em>implicit</em>ly construct one from a relative path, and the newly-constructed <code class="highlighter-rouge">AbsolutePath</code> will have called <code class="highlighter-rouge">makeAbsolutePath</code> to do all the work to make the actual absolute path needed. You can even do the super offensive version in this same way:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const RelativePath relativePath{"my_stuff/texture.png"};
const AbsolutePath absolutePath = relativePath;
</code></pre></div></div>

<p>The new <code class="highlighter-rouge">absolutePath</code> variable is now tilde-expanded and all that stuff, and everything “just works.”</p>

<p>(Note: some people won’t like this, and it legitimately may not suit your application. The implicit call to <code class="highlighter-rouge">makeAbsolutePath</code> is almost certainly going to involve dynamic memory allocation and lots of complicated logic, and having it happen without your explicit intention may be a performance bug, if you’re programming on the chip in my washing machine.)</p>

<p>At the end of all this, we have type-safe paths that express our intentions when reading the source code, and are easy to use correctly (pass in a relative path if you want… I’ll convert it to an absolute path for you!) and hard to use incorrectly (compiler errors if you do it wrong). This makes for a clean, friendly, usable API that gives my anxiety a much-needed break.</p>

<h2 id="addendum">Addendum</h2>

<p>If you’re like me, the code duplication here makes your eyes hurt a tiny, tiny bit. Okay, not even hurt, just kind of itch:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct AbsolutePath {
    explicit AbsolutePath(std::string s) : path{std::move(s)} {}
    std::string path;
};
struct RelativePath {
    explicit RelativePath(std::string s) : path{std::move(s)} {}
    std::string path;
};
</code></pre></div></div>

<p>We have the <em>exact same</em> shape of struct in this example, differing only in the name. In fact, differing in only PART of the name–they’re both paths, just different sorts of paths.</p>

<p>We can factor out this duplication by using a small, simple template, and using a trick involving empty <em>tag types</em>. This was inspired by an approach I saw recently taken by Rust’s <a href="https://github.com/servo/euclid">euclid</a> crate for encoding units into their different geometric types.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template&lt;typename PathTag&gt;
struct Path {
    explicit Path(std::string s) : path{std::move(s)} {}
    std::string path;
};
struct RelativeTag {};
struct AbsoluteTag {};

using RelativePath = Path&lt;RelativeTag&gt;;
using AbsolutePath = Path&lt;AbsoluteTag&gt;;
</code></pre></div></div>

<p>Using this trick you get the exact same semantics as the earlier approach–you still can’t assign between <code class="highlighter-rouge">AbsolutePath</code> and <code class="highlighter-rouge">RelativePath</code> (they’re different types still, because the template parameters are different), and the core logic is factored out. Of course, it is more lines of code, but since you’re using a template, you get to feel smart.</p>

<p>When we add the other constructor to <code class="highlighter-rouge">AbsolutePath</code>, it gets trickier. <code class="highlighter-rouge">RelativePath</code> can stay just being a type alias, but we actually need to create a new type for <code class="highlighter-rouge">AbsolutePath</code> so we can add a constructor to it. I solved it this way:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct AbsolutePath : Path&lt;AbsoluteTag&gt; {
    using Path::Path; // inherit base class constructors
    AbsolutePath(const RelativePath&amp;); // yada yada
};
</code></pre></div></div>

<p>Probably an overly complicated abstraction for this simple case, where we only have two types of paths, and their internal structure is really simple. It might be useful, though, for other applications of this pattern of wrapping simple, less-meaningful types in stronger wrappers.</p>

<p>;</p>


  </div><a class="u-url" href="/2019/01/19/stop-using-bare-strings.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Your awesome title</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Your awesome title</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
